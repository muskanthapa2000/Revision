// ............................................. var .........................................
     function scope-> When a variable is declared inside a function, it is only accessible within that function and cannot be used outside that function. 
    var declarations are globally scoped or function scoped.
T   hey are hoisted, meaning they are moved to the top of the function or global context during execution.
    var variables can be re-declared within the same scope.
    They have no block-level scope; they are only function-scoped or globally scoped.

        const data =()=>{
            var m = "aaa";
            console.log(m);
        }
         data();
        // console.log(m); // print only within the function 
        console.log(a); // print undefined can be access before initalization 
        var a = "muskan"; // var can be reassigned and redeclared 
        var a = "thapa";
        a = "vishu";

        console.log(a);

// ............................................. let .........................................
   block scope -> A variable when declared inside the if or switch conditions or inside for or while loops, are accessible within that particular condition or loop. 
    let declarations are block-scoped, meaning they are confined to the nearest enclosing block or statement.
    They are also hoisted but remain in the "temporal dead zone" (TDZ) until they are assigned a value.
    let variables cannot be re-declared within the same scope.
    They provide a safer and more predictable way of declaring variables.

        const dd = (love = true) => {
            if (love) {
                var n = "aaa";
                console.log(n);
            }
            }

        dd();
        
        // console.log(name); // shows error cannot access before initalization 
        let name = "muskan"; // let can be reassigned but not redeclared 
        name = "thapa";
        console.log(name);

// ............................................. const .........................................
const declarations are also block-scoped, like let.
They must be initialized with a value at the time of declaration.
They cannot be reassigned after initialization, but their contents (for objects and arrays) can be modified.

         //  block scope 
        //  console.log(b) // shows error cannot access before initalization  
        const b = "muskan";// const can not be reassigned and redeclared 
        // b = "aa";
        console.log(b)

//..............................................CLOSURE..........................................
A closure is a function that "closes over" or captures the lexical scope in which it is defined, allowing it to access and manipulate variables from that enclosing scope even after the outer function has finished executing. Closures are a powerful tool for maintaining state, data encapsulation, and creating modular code.
Closures are a fundamental concept in programming, particularly in languages that support first-class functions, such as JavaScript, Python, and Ruby. A closure is a function that "closes over" or captures the lexical scope in which it is defined, allowing it to access and manipulate variables from that enclosing scope even after the outer function has finished executing. Closures are a powerful tool for maintaining state, data encapsulation, and creating modular code.
function test (){
    let a =300;
    let fun = function inner(){
        a=10;
        return a*a;
    }
    a=10;
    return fun;
}

let inner = test();
console.log(inner());

//  output 100

// ............................... call function ......................................
 The call method is used to invoke a function with a specified this value and a set of arguments. It allows you to pass arguments to a function as individual arguments, rather than as an array.
 if we want to call similar function in another function (function write within the function)

    let userDetail = {
        name : "muskan",
        age : 24,
        city : "ludhiana",
         printDetail: function(){
            console.log(this);
         }
    }
    userDetail.printDetail();

    let userDetail1 = {
        name : "vishu",
        age : 21,
        city : "ludhiana",
    }
    userDetail.printDetail.call(userDetail1);

//......................................... apply ............................................ 
 The apply method is similar to call, but it allows you to pass arguments to a function as an array. This can be useful when the number of arguments is dynamic or unknown.
 used when a function is called outside the every function , acception array as a parameter 

        let printDetail = function(country, profession) {
            console.log(this.name + " " + country + " " + profession);
        }

        let userDetail2 = {
            name: "muskan",
            age: 24,
            city: "ludhiana",
        }
        printDetail.apply(userDetail2, ["india", "engii"]);

        let userDetail3 = {
            name: "vishu",
            age: 21,
            city: "ludhiana",
        }
        printDetail.apply(userDetail3, ["india", "developer"]);



//......................................... bind ............................................ 
 The bind method is used to create a new function with a specified this value and partially pre-filled arguments. It does not immediately invoke the function; instead, it returns a new function that can be invoked later.
 craetes a copy of the function and store data into that 
let printDetails = function(country , profession) {
            console.log(this.name + " " + country + " " + profession);
        }

        let userDetail4 = {
            name: "muskan",
            age: 24,
            city: "ludhiana",
        }
        let newuser = printDetails.bind(userDetail4, "india", "engii");
        newuser();
        console.log(newuser())

        let userDetail5 = {
            name: "vishu",
            age: 21,
            city: "ludhiana",
        }
       let newUser1 =  printDetails.bind(userDetail5,"india", "developer");
       newUser1();
       console.log(newUser1())

//    ................................................. Hoisting ...........................

 Hoisting is a JavaScript mechanism that moves variable and function declarations to the top of their containing scope during the compilation phase. In simpler terms, it means that you can use variables and functions before they are declared in your code, and they will be "hoisted" to the top of their respective scope.
It's important to note that hoisting only moves the declarations themselves, not the assignments or initializations. This can lead to unexpected behavior if you're not aware of how hoisting works.
  you can call the function even before its actual declaration in the code.
     
hoistedFunction(); // Output: "Hello, I'm a hoisted function!"

        function hoistedFunction() {
        console.log("Hello, I'm a hoisted function!");
        }
 

//    ................................................. Difference between map and ForEach. detail with example ...........................

map and forEach are both methods in JavaScript used to iterate over elements in an array, but they have distinct differences in terms of their purpose and return values.

    forEach is used for iterating over an array and executing a provided callback function on each element of the array.
    It doesn't create a new array or modify the existing one; it's primarily used for performing actions (e.g., logging, side effects) on each element.
    Return Value:
    forEach does not return a new array or any value. It returns undefined.
    Syntax:
    array.forEach(callback(currentValue, index, array), thisArg);

    const numbers = [1, 2, 3, 4, 5];
    numbers.forEach(function (number) {
    console.log(number);
    });

    map is used for iterating over an array and transforming each element based on a provided callback function.
    It creates a new array with the results of applying the callback function to each element, allowing you to generate a modified version of the original array.
    Return Value:
    map returns a new array with the modified elements, leaving the original array unchanged.
    const newArray = array.map(callback(currentValue, index, array), thisArg);

    const numbers = [1, 2, 3, 4, 5];

    const squaredNumbers = numbers.map(function (number) {
    return number * number;
    });
    console.log(squaredNumbers); // Output: [1, 4, 9, 16, 25]


//    ................................................. What are hooks? more detail with example ...........................

    In the context of React, "hooks" refer to a set of functions that allow you to "hook into" and use state, side effects, and other React features in functional components. Before the introduction of hooks, these features were primarily available in class components. Hooks were introduced in React 16.8 to address various challenges with class components and make it easier to manage component logic in functional components.
    React provides several built-in hooks, with useState and useEffect being the most commonly used ones. Here's a detailed explanation of these hooks with examples:

    The useState hook allows functional components to manage local state. It returns an array with two elements: the current state value and a function to update that value. You can use multiple useState calls to manage different pieces of state in a single component.
    useEffect Hook:

    The useEffect hook allows you to perform side effects in functional components. It takes two arguments: a function to run the effect and an array of dependencies. The effect function is called after the component renders, and it can be used for tasks like data fetching, 
    DOM manipulation, and more. The dependencies array specifies when the effect should run.

//    ................................................. What is the difference between useState and useEffect?  ...........................

    useState is primarily used for managing and updating component state.
    useEffect is used for handling side effects, such as data fetching and DOM manipulation.
    useState updates and re-renders the component when the state changes.
    useEffect runs side effects after the component renders and can be controlled based on dependencies.
    You can use multiple useState hooks in a component to manage multiple state variables.
    You typically use one or more useEffect hooks to handle various side effects in a component.


//    ................................................. What is Memoization? with example ...........................
    Memoization is an optimization technique used in computer programming to speed up the execution of functions by caching their results. It involves storing the results of expensive function calls and returning the cached result when the same inputs occur again. This avoids redundant calculations, improving performance for functions with repeated or expensive computations.
    The idea behind memoization is to trade memory space for faster execution time, making it especially useful in scenarios where a function's input/output relationship is deterministic and expensive to compute.

    import React, { useMemo, useState } from 'react'
    function Counter() {
    const [countOne , setCountOne] = useState(0);
    const [countTwo , setCountTwo] = useState(0)
        const IncrementOne =()=>{
            setCountOne(countOne+1);
        }
        const IncrementTwo =()=>{
            setCountTwo(countTwo+1);
        }

    const memofunction = useMemo(()=>{
            let i =0;
            while(i<99999999) i++;
            return countOne%2===0;

    } , [countOne])
  return (
    <div>
        <h1>COUNTER APP USING USE MEMO</h1>
        <button onClick={IncrementOne}>INCREMENT </button>: {countOne}
        <span>{memofunction ? "even" : "odd"}</span> <br></br>
        <button onClick={IncrementTwo}>INCREMENT </button>: {countTwo} 
    </div>
  )
}

//    ................................................. Difference between shallow copy and deep copy............................

Shallow copy and deep copy are two different approaches to copying objects or arrays in programming. The key distinction between them lies in how they handle nested objects and arrays within the source object. Let's explore the differences with examples.

A shallow copy of an object or array creates a new object or array with a new reference to the top-level elements. However, it does not create copies of nested elements; instead, it maintains references to the same nested elements as the original object or array. Shallow copies are faster and use less memory, but changes to nested elements are shared between the original and the copy.
const originalArray = [1, 2, [3, 4]];
// Using the spread operator to create a shallow copy
const shallowCopy = [...originalArray];
shallowCopy[2].push(5);
console.log(originalArray); // [1, 2, [3, 4, 5]]
console.log(shallowCopy);   // [1, 2, [3, 4, 5]]

A deep copy, on the other hand, creates a new object or array with completely duplicated elements, including nested objects and arrays. As a result, changes to nested elements in a deep copy do not affect the original object or array. Deep copies are safer when you need to modify the copied structure independently.
const originalArray = [1, 2, [3, 4]];
// Using a deep copy method
function deepCopy(obj) {
  return JSON.parse(JSON.stringify(obj));
}
const deepCopyArray = deepCopy(originalArray);
deepCopyArray[2].push(5);
console.log(originalArray); // [1, 2, [3, 4]]
console.log(deepCopyArray); // [1, 2, [3, 4, 5]]

//    .................................................  difference between FrameWork and Library............................

    A framework is a pre-established architecture for building applications. It provides a structure, a set of rules, and a methodology to develop software. In a framework, the overall control flow of the application is managed by the framework itself, and developers build their code within the framework's structure. Frameworks are opinionated and provide a more complete, top-down solution for building applications.
    Key characteristics of a framework:
    Inversion of Control (IoC): In a framework, the control flow is inverted. Instead of the developer calling specific functions, the framework calls the developer's code in response to specific events or requests. The developer writes code that fits within the framework's design.
    Comprehensive: Frameworks provide a broader, integrated solution for application development, including components for UI, data management, routing, and more.
    Opinionated: Frameworks often come with established conventions, coding patterns, and best practices. Developers using a framework are expected to follow these conventions.
    Overhead: Frameworks can be more substantial and come with more inherent complexity, which can make them suitable for larger, more complex projects.
    Example of a Framework:
    Ruby on Rails: A web application framework for Ruby that provides a complete structure for building web applications, including databases, routing, and front-end development.

    A library, on the other hand, is a collection of pre-written code that provides specific functionality or tools for developers. With a library, developers retain control over the application's architecture and flow. Developers can use libraries to handle specific tasks, such as parsing JSON or making HTTP requests, without being locked into a particular application structure.
    Key characteristics of a library
    Control: Developers maintain control over the application's overall architecture and use libraries as needed to perform specific tasks.
    Modularity: Libraries are often designed to be modular, allowing developers to pick and choose which specific functionality they want to use.
    Flexibility: Libraries can be used in different projects, and developers have more flexibility in how they integrate them into their code.
    Lower Overhead: Libraries tend to have lower overhead compared to frameworks, making them more suitable for small to medium-sized projects.
    Example of a Library:
    React: A JavaScript library for building user interfaces. React provides specific tools for rendering UI components, but it doesn't dictate the overall application structure, routing, or state management. Developers have more control over these aspects and can choose additional libraries to complement React as needed.

//    ................................................. What are callback functions............................

    Callback functions are a fundamental concept in JavaScript and other programming languages. They are functions that are passed as arguments to other functions and are executed at a later time or under certain conditions. Callbacks are often used in asynchronous programming, event handling, and various situations where you want to perform an action after another action is completed
    function doSomethingAsync(callback) {
        // Some asynchronous operation
        setTimeout(function () {
            // After the operation is complete, call the callback
            callback();
        }, 1000);
        }
        function myCallback() {
        console.log('Callback function executed');
        }
        // Call a function and pass the callback function as an argument
        doSomethingAsync(myCallback);

//    ................................................. Difference between React and Redux.............................

React and Redux are both popular JavaScript libraries used in web development, but they serve different purposes and often work together to build complex applications. Here are the key differences between React and Redux:

Purpose:
React: React is a JavaScript library for building user interfaces. It provides a component-based architecture, allowing you to create reusable UI components and manage the rendering of these components in a declarative way.
Redux: Redux is a state management library. It helps manage the state of your application, making it predictable and centralized. Redux is often used with React (or other libraries/frameworks) to handle the state of complex applications.
State Management:
React: React has its own built-in state management. Each React component can have its local state, which can be used to manage component-specific data. However, for global application state and more complex scenarios, React can become challenging to manage.
Redux: Redux is designed specifically for global state management. It provides a centralized store where the entire application's state is stored. Components can access and modify this state using actions and reducers, making it easier to handle complex application states.
Component Hierarchy:
React: React components are organized in a tree hierarchy. Each component can have its own local state, which is not directly shared with other components. Data sharing between components usually involves passing props down the tree.
Redux: Redux allows data to be shared across components without the need for direct prop passing. Components can connect to the Redux store to access global state, and updates are propagated through the store to all connected components.
Data Flow:
React: React follows a unidirectional data flow. Data is passed down from parent to child components using props. If child components need to update the parent's state, callbacks or events are used.
Redux: Redux enforces a strict unidirectional data flow. Actions are dispatched to the store to modify the state, and these changes are propagated to connected components. Components do not directly modify the state but rather trigger actions.
Complexity:
React: React is a library focused on the view layer of an application. It is relatively simple and lightweight, making it easy to get started with for building user interfaces.
Redux: Redux introduces additional complexity, especially for small and simple applications. It is best suited for large-scale applications with complex state management requirements.
Integration:
React: React can be used standalone or integrated with other state management solutions. While it has built-in state management, it can also work well with Redux, MobX, and other state management libraries.
Redux: Redux is a dedicated state management library that can be used with various UI libraries and frameworks, not just React. It is commonly used with React, Angular, and Vue.js, among others.

//    ................................................. difference between redux and context API.............................

Redux and the Context API are both solutions for managing the state of a React application, but they have some differences in terms of complexity, ecosystem, and use cases. Here's a comparison between Redux and the Context API:
Complexity:
Redux: Redux is a dedicated state management library. It provides a clear and well-defined pattern for managing application state, involving actions, reducers, and a centralized store. This makes it powerful for handling complex state and large-scale applications but can introduce some initial setup complexity.
Context API: The Context API is a feature in React that allows you to share state between components without a third-party library. It is simpler to use and set up compared to Redux. However, it is not as opinionated or structured as Redux, which means you have more flexibility but may need to implement some conventions yourself.
Ecosystem
Redux: Redux has a rich ecosystem with various middleware, dev tools, and libraries that can enhance its capabilities. It's well-established and widely used in the React community. There are also bindings like react-redux that make it easy to integrate with React components.
Context API: The Context API is part of React and doesn't have as extensive an ecosystem as Redux. While you can build your own utilities and patterns around the Context API, it may not have as many ready-made solutions and middleware options as Redux.
Scalability:
Redux: Redux is designed to handle complex state management, making it a strong choice for large and complex applications with a lot of shared state and interactions between components.
Context API: The Context API is more lightweight and suitable for smaller to medium-sized applications. While it can handle state sharing between components, it may become less convenient for very large applications with extensive state management requirements.
Developer Experience:
Redux: Redux provides a more structured and opinionated way of handling state, which can lead to improved code maintainability, debugging, and testing. However, the initial learning curve can be steeper.
Context API: The Context API is more flexible and forgiving, which can be helpful for simple applications or for getting started quickly. It may not enforce strict patterns, making it easier for beginners but potentially leading to less consistency and predictability in larger codebases.
Use Cases:
Redux: Redux is a suitable choice when you have complex application state that needs to be shared among various components, or when you need to handle asynchronous data flow, caching, and time-travel debugging. It's also a good choice for applications with complex UI interactions.
Context API: The Context API is a good choice for simpler applications or when you want to share state between a few closely related components. It's also a good option when you prefer a lightweight solution and don't need the advanced features of Redux.

//    ................................................. Explain Async Await.....................

    async/await is a feature in JavaScript used for handling asynchronous operations more concisely and in a more readable way. It's built on top of Promises and provides a more straightforward syntax for writing asynchronous code that behaves like synchronous code. async/await was introduced in ECMAScript 2017 (ES8) and is supported in modern JavaScript environments, including Node.js and browsers.

    Here's how async/await works:
    async Function:
    You declare an async function using the async keyword before the function definition. An async function returns a Promise implicitly, allowing you to use await within the function to wait for Promises to resolve.
    Inside an async function, you can use the await keyword before a Promise. await pauses the execution of the function until the Promise resolves. If the Promise resolves with a value, await returns that value; if it rejects, it throws an error.
    Error Handling:
    You can use try...catch blocks to handle errors when working with await. If a Promise rejects and throws an error, it can be caught and handled using regular error-handling techniques.

//    .................................................What are Promises and its states? .....................

Promises are a feature in JavaScript used for handling asynchronous operations. They provide a more structured and flexible way to deal with asynchronous code compared to callbacks. Promises represent a value that may not be available yet but will be resolved or rejected in the future. Promises help in writing cleaner and more readable asynchronous code.
A Promise can be in one of three states:
Pending:
When a Promise is created, it is in the pending state. This means that the asynchronous operation it represents has not completed yet. The Promise is "waiting" for the operation to either resolve or reject.
Fulfilled (Resolved):
If the asynchronous operation succeeds, the Promise transitions to the fulfilled (resolved) state. This means that the operation completed successfully, and the Promise now has a resolved value that can be accessed.
Rejected:
If the asynchronous operation encounters an error or fails, the Promise transitions to the rejected state. In this state, the Promise contains a reason for the failure, typically an error object.

//    .................................................What are hooks? .....................

Hooks are a feature in React, introduced in React 16.8, that allow you to use state and other React features in functional components. Before hooks, state management and lifecycle methods were primarily available in class components. Hooks make it easier to reuse stateful logic, manage component state, and interact with React's component lifecycle in functional components.
Some of the most commonly used hooks include:
useState: This hook allows functional components to manage local component state. It takes an initial state as an argument and returns the current state and a function to update it.
useEffect: useEffect allows you to perform side effects in functional components. You can use it to handle tasks like data fetching, setting up subscriptions, and manually changing the DOM.
useContext: This hook allows you to access the React context without having to wrap your components in a Context.Consumer.

//    ................................................. Explain oops concept. .....................

Object-Oriented Programming (OOP) is a programming paradigm based on the concept of "objects." It organizes data and behavior into reusable structures called classes, which are templates for creating objects. OOP is designed to model real-world entities and their interactions, making it a powerful and widely used approach for software development.
The fundamental concepts of OOP are:
Classes and Objects:
Class: A class is a blueprint or template for creating objects. It defines the structure and behavior of objects of that class. Classes encapsulate data (attributes) and methods (functions).
Object: An object is an instance of a class. It represents a specific instance of the class and can have its own unique data and state.
Encapsulation:
Encapsulation is the practice of bundling data (attributes) and the methods (functions) that operate on that data into a single unit, called a class. It allows you to hide the internal details of how an object works and expose a controlled interface for interacting with it.
Inheritance:
Inheritance is a mechanism that allows a new class (subclass or derived class) to inherit properties and behaviors from an existing class (superclass or base class). This promotes code reuse and the creation of hierarchies of related classes.
Polymorphism:
Polymorphism allows objects of different classes to be treated as objects of a common superclass. It enables you to write more generic and flexible code. Polymorphism can be achieved through method overriding and interfaces in some OOP languages.
Abstraction:
Abstraction is the process of simplifying complex reality by modeling classes based on the essential attributes and behaviors. It helps manage complexity by showing only relevant details and hiding unnecessary complexity.
Method Overriding:
Method overriding is a feature that allows a subclass to provide a specific implementation for a method that is already defined in its superclass. This enables customization of behavior while maintaining the inheritance hierarchy.
Composition:
Composition is the practice of creating complex objects by combining simpler objects. It's an alternative to inheritance for building relationships between classes and is often used to create more flexible and maintainable code.

class Animal {
  constructor(name) {
    this.name = name;
  }
  speak() {
    console.log(`${this.name} makes a sound.`);
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name);
    this.breed = breed;
  }
  speak() {
    console.log(`${this.name} (a ${this.breed} dog) barks.`);
  }
}

const cat = new Animal('Whiskers');
const dog = new Dog('Buddy', 'Golden Retriever');
cat.speak(); // Whiskers makes a sound.
dog.speak(); // Buddy (a Golden Retriever dog) barks.
In this example, we have two classes: Animal and Dog. Dog is a subclass of Animal and inherits its properties and methods. speak is overridden in the Dog class, demonstrating method overriding. Polymorphism is achieved when we call the speak method on cat and dog objects, and the appropriate implementation is executed based on the object's actual type.

//    ................................................. Difference between states and props. .....................

In React, both props and state are used to manage data in components, but they serve different purposes and have distinct characteristics. Here are the key differences between them:
Props:
Immutable (Read-Only):
Props are passed from a parent component to a child component. Once set, props are immutable (read-only) in the child component. The child component cannot modify the props it receives.
Parent-to-Child Communication:
Props are primarily used for communication between a parent component and its child components. The parent component can pass data (and functions) down to its children via props.
Functional Components:
Props are commonly used with functional components, and they are the primary mechanism for passing data between components in a React application.
Usage:
Props are declared as attributes in JSX and are accessed in the child component using the props object.

State:
Mutable (Can be Changed):
State represents the internal state of a component and can be modified. It is managed within the component and can be updated using the setState function.
Component's Own Data:
State is used to manage data that belongs to and can be changed by the component itself. It is local and specific to the component in which it is defined.
Class Components:
State is commonly used with class components. In functional components, you can use the useState hook to introduce state.
Usage:
State is declared and initialized in the constructor (for class components) or using the useState hook (for functional components). It is accessed using this.state in class components or directly as a variable in functional components.


//    .................................................  difference between local storage and session storage? .....................

Local Storage and Session Storage are both web storage solutions provided by web browsers, and they share many similarities. However, the key difference between them lies in the duration of the stored data and the scope of accessibility:
Duration of Data:
Local Storage:
Data stored in Local Storage persists even after the browser is closed and reopened. It has a longer lifespan and is intended for persistent storage.
Session Storage:
Data stored in Session Storage is only available for the duration of a page session. It is cleared when the user closes the browser tab or window.

Scope of Accessibility:
Local Storage:
Data stored in Local Storage is shared across all tabs and windows opened from the same origin (same protocol, domain, and port). This means that if you set data in one tab, it will be accessible in another tab or window.
Session Storage:
Data stored in Session Storage is limited to the particular tab or window that set the data. It is not shared between different tabs or windows.

Use Cases:
Local Storage:
Suitable for storing data that needs to persist across browser sessions, such as user preferences, authentication tokens, or other long-term settings.
Session Storage:
Useful for storing data that is only relevant for the current session, such as temporary settings, data needed for a single operation, or short-term user input.
// Local Storage
localStorage.setItem('username', 'john_doe');
const localData = localStorage.getItem('username');
console.log('Local Storage Data:', localData);

// Session Storage
sessionStorage.setItem('theme', 'light');
const sessionData = sessionStorage.getItem('theme');
console.log('Session Storage Data:', sessionData);


//    .................................................useCallback hook..........................
The useCallback hook in React is used to memoize functions, similar to how useMemo is used to memoize values. It's particularly helpful in scenarios where you want to avoid the recreation of functions on each render, especially when passing functions as props to child components.
When a function is defined inside a functional component, it is recreated on every render. If this function is passed down as a prop to child components, it can trigger unnecessary re-renders in those child components. useCallback addresses this issue by memoizing the function and only recreating it when its dependencies change.

const memoizedCallback = useCallback(() => {
  // function body
}, [dependencies]);


//    ........................................ Event loop ..........................

The event loop is a fundamental concept in the asynchronous programming model, and it is especially important in JavaScript. It is the mechanism that allows JavaScript to handle multiple tasks concurrently without blocking the execution of the program. The event loop is an integral part of the JavaScript runtime environment.
Here's a high-level overview of how the event loop works:

Call Stack:
The JavaScript runtime maintains a call stack, which is a data structure that keeps track of the execution context of functions (where the program is in its execution).
Execution:
When a function is called, its execution context is pushed onto the call stack, and the function's code is executed.
Asynchronous Operations:
JavaScript supports asynchronous operations, such as setTimeout, AJAX requests, and event handlers. When an asynchronous operation is encountered, it is offloaded to the browser's APIs (or similar mechanisms in other environments), and the JavaScript engine continues to execute the remaining synchronous code.
Callback Queue:
When an asynchronous operation completes, a callback function is placed in the callback queue.
Event Loop:
The event loop continuously checks the call stack and the callback queue. If the call stack is empty, it takes the first function from the callback queue and pushes it onto the call stack for execution.
console.log('Start');
setTimeout(() => {
  console.log('Timeout callback');
}, 1000);

console.log('End');

//    ........................................ What is prop Drilling .............................

Prop drilling (also known as "threading props" or "passing props down the component tree") is a situation in React where you need to pass data through several layers of nested components in order to get it to a deeply nested child component. It occurs when you have data at the top level of your component tree that needs to be accessed by a component deep down in the tree.

//    ........................................ What is  Virtual Dom?.............................

The Virtual DOM (Document Object Model) is a concept used in web development and, more specifically, in the context of front-end libraries and frameworks like React. It is a representation of the actual DOM in the form of a virtual copy or tree structure in memory.
Here's how the Virtual DOM works:
Real DOM:
The browser's Document Object Model (DOM) represents the structure of a web page as a tree of objects, where each object corresponds to an element on the page (like div, p, span, etc.).
Virtual DOM:
The Virtual DOM is a lightweight, in-memory representation of the actual DOM. It's a JavaScript object that mimics the structure of the real DOM.
React and Reconciliation:
In React, when the state of a component changes, a new Virtual DOM tree is created, representing the updated state.
React then performs a process called reconciliation, where it compares the new Virtual DOM with the previous one to identify the differences (known as the "diffing" process).
The differences are computed efficiently, and a minimal set of changes needed to update the real DOM is determined.
Update to the Real DOM:
Instead of updating the entire real DOM, React only makes the necessary changes based on the computed differences.
This approach is more efficient than directly manipulating the real DOM for every state change, as updating the real DOM can be a costly operation in terms of performance.

The Virtual DOM provides several benefits:
Efficiency:
By reducing the number of direct manipulations to the real DOM, the Virtual DOM improves the overall performance of the application.
Abstraction:
Developers can work with the Virtual DOM as if it were the real DOM, and React takes care of efficiently updating the actual DOM.
Reusability:
The Virtual DOM enables the creation of reusable components in React. When a component's state changes, a new Virtual DOM is created, making it easier to manage the state of the entire application.
While the Virtual DOM is a concept commonly associated with React, other front-end libraries and frameworks also leverage similar techniques to optimize DOM manipulation and improve application performance. The idea is to minimize the direct interaction with the expensive real DOM operations whenever possible.


//    ..................................Class Components vs Functional Components ..............................

In React, components are the building blocks of a user interface. Two main types of components are Class Components and Functional Components. Each type has its own syntax, features, and use cases.
Class Components:
Syntax:
import React, { Component } from 'react';
class MyClassComponent extends Component {
  render() {
    return <p>Hello from Class Component</p>;
  }
}
export default MyClassComponent;

State:
Class components can have state. You can use the this.state and this.setState methods to manage and update state.
class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }
  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };
  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.increment}>Increment</button>
      </div>
    );
  }
}
Lifecycle Methods:
Class components have lifecycle methods (componentDidMount, componentDidUpdate, componentWillUnmount, etc.) that allow you to execute code at specific points in the component's lifecycle.
class MyComponent extends Component {
  componentDidMount() {
    console.log('Component is mounted');
  }
  componentWillUnmount() {
    console.log('Component is about to be unmounted');
  }
  render() {
    return <p>Hello from Class Component</p>;
  }
}

Functional Components:
Syntax:
import React from 'react';

const MyFunctionalComponent = () => {
  return <p>Hello from Functional Component</p>;
};
export default MyFunctionalComponent;
State:
Functional components did not have state until the introduction of Hooks in React 16.8. With Hooks, functional components can now use state and other features previously exclusive to class components.
import React, { useState } from 'react';
const Counter = () => {
  const [count, setCount] = useState(0);
  const increment = () => {
    setCount(count + 1);
  };
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
};

Lifecycle Methods:
Before React 16.3, functional components did not have lifecycle methods. With the introduction of Hooks, useEffect can be used to achieve effects similar to lifecycle methods.
jsx
Copy code
import React, { useEffect } from 'react';
const MyComponent = () => {
  useEffect(() => {
    console.log('Component is mounted');
    return () => {
      console.log('Component is about to be unmounted');
    };
  }, []);
  return <p>Hello from Functional Component</p>;
};
Choosing Between Class and Functional Components:
Stateful vs Stateless:
Use a class component if you need to manage state or use lifecycle methods.
Use a functional component if your component doesn't need state or lifecycle methods (or if you are using Hooks to manage state).
Readability:
Functional components with Hooks are often more concise and considered more readable.
Lifecycle Methods:
If you need to use lifecycle methods, you must use a class component.
Class Components in Existing Codebases:
For older codebases or projects that have not migrated to React Hooks, class components may still be in use.


//    ........................................  controlled and uncontrolled components .............................

The terms "controlled components" and "uncontrolled components" refer to two different ways of handling and managing form elements (like input fields, checkboxes, and radio buttons) in React. These concepts are particularly relevant when dealing with state and user input.
Controlled Components:
A controlled component is a form element whose value is controlled by React state. The component receives its current value as a prop and notifies changes through callbacks like onChange.
Characteristics:
The value of the form element is stored in the component's state.
Changes to the input value are handled by updating the state with the onChange event.
The component re-renders when its state changes, updating the displayed value of the form element.

import React, { useState } from 'react';
const ControlledInput = () => {
  const [value, setValue] = useState('');

  const handleChange = (event) => {
    setValue(event.target.value);
  };

  return (
    <input type="text" value={value} onChange={handleChange} />
  );
};

Uncontrolled Components:
An uncontrolled component is a form element whose value is not controlled by React state. The component's value is handled by the DOM itself, and React is not directly involved in tracking or updating its state.
Characteristics:
The value of the form element is not stored in the component's state.
The component does not re-render when the value changes; it relies on the DOM to maintain and update its value.
Refs are often used to interact with the underlying DOM element directly.

import React, { useRef } from 'react';
const UncontrolledInput = () => {
  const inputRef = useRef();
  const handleButtonClick = () => {
    alert(`Input Value: ${inputRef.current.value}`);
  };
  return (
    <>
      <input type="text" ref={inputRef} />
      <button onClick={handleButtonClick}>Get Value</button>
    </>
  );
};


//    .................................................  javascript considered a single-threaded language ................................

JavaScript is considered a single-threaded language because it has a single execution thread, meaning that it can only perform one operation at a time in a single sequence. This single-threaded nature is a fundamental characteristic of JavaScript, especially when running in a web browser.
The reason behind JavaScript being single-threaded is rooted in its initial purpose: to enhance the interactivity and responsiveness of web pages. When JavaScript was introduced for web development, it was primarily designed to manipulate the Document Object Model (DOM) and respond to user interactions within a web browser.
Single-Threaded Execution:
Event Loop:
JavaScript uses an event-driven, asynchronous programming model. The event loop is a crucial part of this model. It continuously checks the message queue for events and executes them in the order they are received.

Blocking vs. Non-blocking:
While JavaScript is single-threaded, it can handle asynchronous operations through callbacks, promises, and async/await. This allows non-blocking execution, where the script can initiate an operation (such as an HTTP request) and continue with other tasks while waiting for the operation to complete.

Web Workers (Multi-Threading in JavaScript):
While JavaScript itself is single-threaded, modern web browsers support Web Workers as a mechanism to introduce multi-threading capabilities. Web Workers allow developers to run scripts in the background concurrently with the main thread, enabling parallel execution.
However, it's important to note that Web Workers operate in a separate thread and communicate with the main thread through a message-passing mechanism. They don't share the same scope and memory, and communication between the main thread and a Web Worker involves sending serialized data.

Why Single-Threaded?
The single-threaded nature of JavaScript is intentional and aligns with its role in enhancing the interactivity of web pages. It simplifies the programming model and helps avoid complex issues related to race conditions and shared data in multithreaded environments. It also fits well with the event-driven, asynchronous nature of web development.
While single-threading simplifies the programming model, it requires developers to be mindful of long-running synchronous operations that can block the event loop and lead to unresponsive user interfaces. Asynchronous programming patterns help mitigate this issue by allowing non-blocking execution of tasks.



//    .................................................  React fiber ..................................

React Fiber is an internal implementation detail of the React library that represents a reimplementation of the core algorithm for rendering and updating components in a React application. It was introduced in React 16 to improve the performance and responsiveness of React applications, particularly in scenarios involving large and complex component trees.
Key Features of React Fiber:
Incremental Rendering:
Fiber introduces the concept of incremental rendering, allowing React to split the rendering work into smaller chunks (fibers). This enables the browser to interrupt rendering to handle user input or other high-priority tasks, making the application more responsive.

Prioritization and Scheduling:
Fiber introduces a priority-based scheduling algorithm, allowing React to prioritize and schedule updates based on their priority. This enables React to allocate resources more efficiently and respond quickly to user interactions.

Cancellation of In-progress Work:
React Fiber supports the ability to cancel or interrupt in-progress rendering work. This is useful in scenarios where a higher-priority update needs to be processed, and lower-priority work can be canceled to prioritize the more critical update.

Error Boundaries:
Fiber introduces error boundaries, which are special components that can catch JavaScript errors anywhere in the component tree and log those errors. Error boundaries help prevent the entire application from crashing due to errors in a specific part of the tree.

Improved Developer Tools:
React Fiber provides improved support for developer tools, enabling better debugging and profiling of React applications.

Why "Fiber"?
The term "fiber" in React Fiber does not refer to optical fibers or anything related to networks. Instead, it is a programming term representing a lightweight thread of execution. In the context of React, a "fiber" is a unit of work or a lightweight representation of a component tree node.

How Fiber Works:
Reconciliation Phase:
React Fiber performs a process called reconciliation, which is the process of updating the virtual DOM to match the desired state based on changes in the component tree. This process is performed incrementally and is interruptible.

Commit Phase:
Once the reconciliation is complete, React Fiber enters the commit phase, where it applies the changes to the actual DOM. This phase is also incremental, allowing React to spread the work across multiple frames.

Scheduling and Prioritization:
React Fiber uses a scheduler that prioritizes different types of updates based on their urgency. Updates that are more critical for user experience (e.g., user interactions) are given higher priority.
React Fiber is an internal detail of React, and most React developers do not need to interact directly with it. It provides the foundation for React's performance improvements, allowing developers to build complex and responsive user interfaces with improved efficiency. The benefits of React Fiber are transparent to developers, who continue to write React components using the same API.


//    .................................................  EventEmmitors ....................................

An EventEmitter is a design pattern and a class in many programming languages that provides a mechanism for implementing the observer pattern. The observer pattern is a behavioral design pattern where an object, known as the subject or publisher, maintains a list of dependents, known as observers or subscribers, that are notified of any changes in the subject's state.
In the context of Node.js and JavaScript, EventEmitter is a class provided by the Node.js core module events. It is widely used for handling events and building event-driven architectures.

